{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nvar createBoard = function createBoard(rows, columns) {\n  return Array(rows).fill(0).map(function (_, row) {\n    return Array(columns).fill(0).map(function (_, column) {\n      return {\n        row: row,\n        column: column,\n        opened: false,\n        flagged: false,\n        mined: false,\n        exploded: false,\n        nearMines: 0\n      };\n    });\n  });\n};\n\nvar spreadMines = function spreadMines(board, minesAmount) {\n  var rows = board.length;\n  var columns = board[0].length;\n  var minesPlanted = 0;\n\n  while (minesPlanted < minesAmount) {\n    var rowSelected = parseInt(Math.random() * rows, 10);\n    var columnSelected = parseInt(Math.random() * columns, 10);\n\n    if (!board[rowSelected][columnSelected].mined) {\n      board[rowSelected][columnSelected].mined = true;\n      minesPlanted++;\n    }\n  }\n};\n\nvar createdBoardMined = function createdBoardMined(rows, columns, minesAmount) {\n  var board = createBoard(rows, columns);\n  spreadMines(board, minesAmount);\n  return board;\n};\n\nvar cloneBoard = function cloneBoard(board) {\n  return board.map(function (row) {\n    return row.map(function (field) {\n      return _objectSpread({}, field);\n    });\n  });\n};\n\nvar getNeighbors = function getNeighbors(board, row, column) {\n  var neighbors = [];\n  var rows = [row - 1, row, row + 1];\n  var columns = [column - 1, column, column + 1];\n  rows.forEach(function (getRow) {\n    columns.forEach(function (getColumn) {\n      var different = getRow !== row || getColumn !== column;\n      var validRow = getRow >= 0 && getRow < board.length;\n      var validColumn = getColumn >= 0 && getColumn < board[0].length;\n\n      if (different && validRow && validColumn) {\n        neighbors.push(board[getRow][getColumn]);\n      }\n    });\n  });\n  return neighbors;\n};\n\nvar safeNeighborhood = function safeNeighborhood(board, row, column) {\n  var safes = function safes(results, neighbor) {\n    return results && !neighbor.mined;\n  };\n\n  return getNeighbors(board, row, column).reduce(safes, true);\n};\n\nvar openField = function openField(board, row, column) {\n  var field = board[row][column];\n\n  if (!field.opened) {\n    field.opened = true;\n\n    if (field.mined) {\n      field.exploded = true;\n    } else if (safeNeighborhood(board, row, column)) {\n      getNeighbors(board, row, column).forEach(function (field) {\n        return openField(board, field.row, field.column);\n      });\n    } else {\n      var neighbors = getNeighbors(board, row, column);\n      field.nearMines = neighbors.filter(function (neighborField) {\n        return neighborField.mined;\n      }).length;\n    }\n  }\n};\n\nvar fields = function fields(board) {\n  var _ref;\n\n  return (_ref = []).concat.apply(_ref, _toConsumableArray(board));\n};\n\nvar hadExplosion = function hadExplosion(board) {\n  return fields(board).filter(function (field) {\n    return field.exploded;\n  }).length > 0;\n};\n\nvar pendding = function pendding(field) {\n  return field.mined && field.flagged || !field.mined && !field.opened;\n};\n\nvar wonGame = function wonGame(board) {\n  return fields(board).filter(pendding).length === 0;\n};\n\nvar showMines = function showMines(board) {\n  return fields(board).filter(function (field) {\n    return field.mined;\n  }).forEach(function (field) {\n    return field.opened = true;\n  });\n};\n\nvar toggleFlag = function toggleFlag(board, row, column) {\n  var field = board[row][column];\n  field.flagged = !field.flagged;\n};\n\nvar flagsUsed = function flagsUsed(board) {\n  return fields(board).filter(function (field) {\n    return field.flagged;\n  }).length;\n};\n\nexport { createdBoardMined, cloneBoard, openField, hadExplosion, wonGame, showMines, toggleFlag, flagsUsed };","map":{"version":3,"sources":["/home/andre/Documentos/Udemy Course/mines/Mine/src/functions.js"],"names":["createBoard","rows","columns","Array","fill","map","_","row","column","opened","flagged","mined","exploded","nearMines","spreadMines","board","minesAmount","length","minesPlanted","rowSelected","parseInt","Math","random","columnSelected","createdBoardMined","cloneBoard","field","getNeighbors","neighbors","forEach","getRow","getColumn","different","validRow","validColumn","push","safeNeighborhood","safes","results","neighbor","reduce","openField","filter","neighborField","fields","concat","hadExplosion","pendding","wonGame","showMines","toggleFlag","flagsUsed"],"mappings":"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","sourcesContent":["const createBoard = (rows, columns) => {\n  return Array(rows).fill(0).map((_, row) => {\n    return Array(columns).fill(0).map((_, column) => {\n      return {\n        row,\n        column,\n        opened: false,\n        flagged: false,\n        mined: false,\n        exploded: false,\n        nearMines: 0,\n      }\n    })\n  });\n}\n\nconst spreadMines = (board, minesAmount) => {\n  const rows = board.length;\n  const columns = board[0].length;\n\n  let minesPlanted = 0;\n\n  while (minesPlanted < minesAmount) {\n    const rowSelected = parseInt(Math.random() * rows, 10);\n    const columnSelected = parseInt(Math.random() * columns, 10);\n\n    if ( !board[rowSelected][columnSelected].mined ) {\n      board[rowSelected][columnSelected].mined = true;\n      minesPlanted++;\n    }\n  }\n}\n\nconst createdBoardMined = (rows, columns, minesAmount) => {\n  const board = createBoard(rows, columns);\n  spreadMines(board, minesAmount);\n  return board;\n}\n\nconst cloneBoard = (board) => {\n  return board.map((row) => {\n    return row.map((field) => {\n      return { ...field }\n    });\n  });\n}\n\nconst getNeighbors = (board, row, column) => {\n  const neighbors = [];\n  const rows = [row - 1, row, row + 1];\n  const columns = [column - 1, column, column + 1];\n\n  rows.forEach((getRow) => {\n    columns.forEach((getColumn) => {\n      const different = getRow !== row || getColumn !== column;\n\n      const validRow = getRow >= 0 && getRow < board.length;\n\n      const validColumn = getColumn >= 0 && getColumn < board[0].length;\n\n      if (different && validRow && validColumn) {\n        neighbors.push(board[getRow][getColumn]);\n      }\n    });\n  });\n\n  return neighbors;\n}\n\nconst safeNeighborhood = (board, row, column) => {\n  const safes = ( results, neighbor ) => results && !neighbor.mined;\n  return getNeighbors(board, row, column).reduce(safes, true);\n}\n\nconst openField = (board, row, column) => {\n  const field = board[row][column];\n\n  if (!field.opened) {\n    field.opened = true;\n    if (field.mined) {\n      field.exploded = true;\n    } else if (safeNeighborhood(board, row, column)) {\n      getNeighbors(board, row, column)\n        .forEach((field) => openField(board, field.row, field.column));\n    } else {\n      const neighbors = getNeighbors(board, row, column);\n      field.nearMines = neighbors.filter((neighborField) => neighborField.mined).length;\n    }\n  }\n}\n\nconst fields = (board) => [].concat(...board);\n\nconst hadExplosion = (board) => fields(board)\n  .filter((field) => field.exploded).length > 0;\n\nconst pendding = field => (field.mined && field.flagged) || (!field.mined && !field.opened)\n\nconst wonGame = board => fields(board).filter(pendding).length === 0;\n\nconst showMines = board => fields(board).filter(field => field.mined).forEach(field => field.opened = true)\n\nconst toggleFlag = (board, row, column) => {\n  const field = board[row][column];\n\n  field.flagged = !field.flagged;\n}\n\nconst flagsUsed = (board) => fields(board).filter((field) => field.flagged).length;\n\nexport {\n  createdBoardMined,\n  cloneBoard,\n  openField,\n  hadExplosion,\n  wonGame, \n  showMines,\n  toggleFlag,\n  flagsUsed\n}\n"]},"metadata":{},"sourceType":"module"}